-- ============================================================================
-- USER PROFILES MIGRATION
-- Mexican Dice - Online Multiplayer
-- ============================================================================
-- Creates public.users table for user profiles with RLS policies
-- Run this in Supabase SQL Editor

-- ============================================================================
-- STEP 1: Create Users Table
-- ============================================================================

CREATE TABLE IF NOT EXISTS public.users (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Add index for fast username lookups
CREATE INDEX IF NOT EXISTS idx_users_username ON public.users(username);

-- Comments for documentation
COMMENT ON TABLE public.users IS 'User profiles for online multiplayer - stores display names';
COMMENT ON COLUMN public.users.id IS 'References auth.users(id) - matches Supabase auth user';
COMMENT ON COLUMN public.users.username IS 'Display name for the user (e.g., "Player-4832")';

-- ============================================================================
-- STEP 2: Enable RLS on Users Table
-- ============================================================================

ALTER TABLE public.users ENABLE ROW LEVEL SECURITY;

-- ============================================================================
-- STEP 3: Create RLS Policies for Users Table
-- ============================================================================

-- DROP existing policies if they exist (for re-running migration)
DROP POLICY IF EXISTS "users_select_all" ON public.users;
DROP POLICY IF EXISTS "users_select_self" ON public.users;
DROP POLICY IF EXISTS "users_insert_self" ON public.users;
DROP POLICY IF EXISTS "users_update_self" ON public.users;

-- SELECT: Users can read all profiles (needed to find friends by username)
-- This is safe because usernames are public information
CREATE POLICY "users_select_all"
ON public.users
FOR SELECT
USING (true);

-- INSERT: Users can only insert their own profile
-- Prevents users from creating profiles for other auth users
CREATE POLICY "users_insert_self"
ON public.users
FOR INSERT
WITH CHECK (
  auth.uid() IS NOT NULL
  AND auth.uid() = id
);

-- UPDATE: Users can only update their own profile
-- Allows username changes in the future
CREATE POLICY "users_update_self"
ON public.users
FOR UPDATE
USING (auth.uid() = id)
WITH CHECK (auth.uid() = id);

-- ============================================================================
-- STEP 4: Verification Queries
-- ============================================================================

-- Run these to verify the migration worked:

-- 1. Check table structure
-- SELECT column_name, data_type, is_nullable
-- FROM information_schema.columns
-- WHERE table_name = 'users' AND table_schema = 'public';

-- 2. Check RLS is enabled
-- SELECT tablename, rowsecurity
-- FROM pg_tables
-- WHERE schemaname = 'public' AND tablename = 'users';

-- 3. Check policies exist
-- SELECT policyname, permissive, roles, cmd, qual, with_check
-- FROM pg_policies
-- WHERE schemaname = 'public' AND tablename = 'users';

-- ============================================================================
-- NOTES
-- ============================================================================

-- SECURITY MODEL:
-- - All users can read all usernames (needed for friend lookup)
-- - Users can only create/update their own profile row
-- - Username is auto-generated by ensureUserProfile() function in app
-- - Each auth.users row has exactly 0 or 1 corresponding public.users row

-- USAGE:
-- 1. User signs in anonymously (handled by auth.ts)
-- 2. App calls ensureUserProfile() (in auth.ts)
-- 3. If no row in public.users, generates "Player-XXXX" and inserts
-- 4. Username is displayed in UI and used in games table

-- CLEANUP (if you need to reset):
-- DROP TABLE IF EXISTS public.users CASCADE;
